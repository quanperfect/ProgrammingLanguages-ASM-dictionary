global exit
global string_length
global print_string
global print_char
global print_newline
global print_uint
global print_int
global read_char
global read_word
global parse_uint
global parse_int
global string_equals
global string_copy
global print_err


section .data

newline: db 10
dec_numbers: db '0123456789'


section .text


; Принимает код возврата и завершает текущий процесс
exit:
	mov rax, 60					; sys_exit call
    syscall

; Принимает указатель на нуль-терминированную строку, возвращает её длину
; Исходные данные:
;		rdi - указатель на нуль-терминированную строку
; Вывод по итогу выполнения функции:
;		rax - длина строки
string_length:
	 xor rax, rax	; очищаем rax
	.loop:
		cmp byte[rdi+rax], 0	; проверка символа на нуль-терминатор
		je .end					; нуль-терминатор -> выход
		inc rax					; инкрементируем rax, чтобы перейти на следующий символ в строке
		jmp .loop
	.end:
		ret


; Принимает указатель на нуль-терминированную строку, Вывод по итогу выполнения функцииит её в stdout
; Исходные данные:
;		rdi - указатель на нуль-терминированную строку
; Вывод по итогу выполнения функции:
;		stdout
print_string:
	call string_length		; после вызова rax - длина строки
	mov rsi, rdi			; кладем адрес начала строки
	mov rdx, rax			; количество байт для хранения
	mov rdi, 1				; stdout file descriptor
	mov rax, 1				; sys_write call
	syscall
	xor rax, rax			; очищаем rax
   	ret

; Переводит строку (Вывод по итогу выполнения функцииит символ с кодом 0xA)
; Вывод по итогу выполнения функции:
;		stdout
print_newline:
	mov rdi, 0xA				; закидываем необходимый символ

; Принимает код символа и Вывод по итогу выполнения функцииит его в stdout
; Исходные данные:
;		rdi - код символа
; Вывод по итогу выполнения функции:
;		stdout
print_char:
    mov rax, 1					; sys_write call
    mov rdx, 1					; выделение памяти под один символ
    push rdi					; пушим значение rdi на стек, чтобы сохранить
    mov rdi, 1					; stdout file descriptor
    mov rsi, rsp				; кладем ссылку на код символа
    syscall		
    pop rdi						; достаем значение rdi из стека
    ret

; Вывод по итогу выполнения функцииит знаковое 8-байтовое число в десятичном формате 
; Исходные данные:
;		rdi - знаковое 8-байтовое число в десятичном формате
; Вывод по итогу выполнения функции:
;		stdout
print_int:
    cmp rdi, 0					; сравниваем число с нулем
    jge print_uint				; если >=0, то переход
    push rdi					; кладем число в стек
    mov rdi, '-'				; передаем символ минуса в rdi
    call print_char				; печать минуса
    pop rdi						; попаем число из стека
    neg rdi						; приводим число к нужному виду

; Вывод по итогу выполнения функцииит беззнаковое 8-байтовое число в десятичном формате 
; Совет: выделите место в стеке и храните там результаты деления
; Не забудьте перевести цифры в их ASCII коды.
; Исходные данные:
;		rdi - беззнаковое 8-байтовое число в десятичном формате
; Вывод по итогу выполнения функции:
;		stdout
print_uint:
	mov r9, rsp					; сохраняем начальный указатель на вершину стека
	mov r10, 10					; делитель
	mov rax, rdi				; число, которое нужно перевести
	push 0						; пушим 0, тогда строка прочиталась как нуль-терминированная
.loop:
	xor rdx, rdx				; очищаем rdx
	div r10						; делим число на делитель 10, остаток попадает в rdx
	add rdx, 0x30				; переводим остаток в ASCII код
	dec rsp						; сдвигаем указатель стека
	mov byte[rsp], dl			; сохраняем цифру на стеке
	cmp rax, 0					; закончилось число или нет?
	jnz .loop	
	
	mov rdi, rsp				; помещаем	 адрес начала строки
	push r9						; сохраняем значение r9
	call print_string			; печатаем результат
	pop r9						; достаем значение r9 из стека
	mov rsp, r9					; возвращаем указатель стека в начальное состояние
    ret

; Принимает два указателя на нуль-терминированные строки, возвращает 1 если они равны, 0 иначе
; Исходные данные:
;		rdi - указатель на первую нуль-терминированную строку
; 		rsi - указатель на вторую нуль-терминированную строку
; Вывод по итогу выполнения функции:
;		rax - результат
string_equals:
    xor rax, rax				; очищаем rax
	call string_length			; находим длину первой строки
    mov r10, rax				; сохраняем длину первой строки
    push rdi					; помещаем на стек указатель на первую строку
    mov rdi, rsi				; помещаем в rdi указатель на вторую строку
    pop rsi						; помещаем в rsi указатель на первую строку
    call string_length			; ищем длину второй строки
    cmp rax, r10				; сравнение длин строк
    jne .noteq					; если длины строк не равны, то и строки не равны, значит переход .noteq (notequal)
.loop:
	mov rax, 0					; очищаем rax
	mov al, byte[rsi]			; помещаем младший байт первой строки
	cmp al, byte[rdi]			; сравниваем символы двух строк
	jne .noteq					; если не равны, то переход .noteq (notequal)
	cmp al, 0					; проверка символа на нуль-терминатор
	je .eq						; если нуль-терминатор, переход (строки равны)
	inc rdi						; сдвигаем указатель на вторую строку на следующий символ
	inc rsi						; сдвигаем указатель на первую строку на следующий символ
	jmp .loop					; переход в начало цикла
.noteq:
	xor rax, rax				; очищаем rax (заносим 0), то есть строки не равны (0)
    ret
.eq:	
	mov rax, 1					; кладем 1 в rax, то есть строки равны (1)
	ret  	

; Читает один символ из stdin и возвращает его. Возвращает 0 если достигнут конец потока
; Исходные данные:
;		stdin
; Вывод по итогу выполнения функции:
;		rax - введенный символ
read_char:
	push 0						; резервируем место для чтения
	mov rax, 0					; syscall read number
    mov rdx, 1					; длина в 1 символ
    mov rdi, 0					; stdin file descriptor
    mov rsi, rsp				; адрес, куда будет считываться символ
    syscall
    pop rax						; считываем в rax введенный символ
    ret 

; Принимает: адрес начала буфера, размер буфера
; Читает в буфер слово из stdin, пропуская пробельные символы в начале, .
; Пробельные символы это пробел 0x20, табуляция 0x9 и перевод строки 0xA.
; Останавливается и возвращает 0 если слово слишком большое для буфера
; При успехе возвращает адрес буфера в rax, длину слова в rdx.
; При неудаче возвращает 0 в rax
; Эта функция должна дописывать к слову нуль-терминатор
; Исходные данные:
;	rdi - адрес начала буфера
;	rsi - размер буфера
;	stdin
; Вывод по итогу выполнения функции:
; (при успешном выполнении)
;	rax - адрес буфера
;	rdx - количество символов в слове
; (при неуспешном выполнении)
;	rax - 0
read_word:
	push r12					; сохраняем Callee-saved регистры -
	push r13					; регистры, которые нужно сохранять и восстанавливать вручную тому,
	push r14					; кого вызвали
	mov r12, rdi				; кладем адрес начала буфера
	mov r13, rsi				; кладем размер буфера
	dec r13						; уменьшаем размер буфера на 1 для нуль-терминатора
	xor r14, r14				; очищаем счетчик прочитанных символов
.first_read:
	call read_char				; читаем символ
	cmp rax, 0x0				; проверяем, является ли символ нуль-терминатором
	je .exit					; является -> переход
	cmp rax, 0x20				; проверка на SPACE
	je .first_read				; является -> переход
	cmp rax, 0x9				; проверка на табуляцию
	je .first_read				; является -> переход
	cmp rax, 0xA				; проверка на перевод строки
	je .first_read				; является -> переход
.loop:
	cmp rax, 0x0				; проверяем, является ли символ нуль-терминатором
	je .exit					; является -> переход
	cmp rax, 0x20				; проверка на SPACE
	je .exit					; является -> переход
	cmp rax, 0x9				; проверка на табуляцию
	je .exit					; является -> переход
	cmp rax, 0xA				; проверка на перевод строки
	je .exit					; является -> переход
	mov [r12+r14], al			; кладем символ в буффер
	inc r14						; инкрементируем счетчик прочитанных символов
	cmp r14, r13				; сравниваем кол-во прочитанных символов с размером буфера
	jg .fail					; переход на fail, если буфера не хватает (прочитанных символов больше чем размер буфера)
	call read_char				; читаем символ
	jmp .loop					; переход
.fail:
	pop r14						; восстанавливаем Callee-saved регистры -
	pop r13						; регистры, которые нужно сохранять и восстанавливать вручную тому,
	pop r12						; кого вызвали
	mov rax, 0
	ret
.exit:
	mov byte[r12+r14], 0			
	mov rax, r12				; кладем адрес буфера
	mov rdx, r14				; кладем длину слова
	pop r14						; восстанавливаем Callee-saved регистры - 
	pop r13						; регистры, которые нужно сохранять и восстанавливать вручную тому,
	pop r12						; кого вызвали
	ret

; Принимает указатель на строку, пытается
; прочитать из её начала беззнаковое число.
; Возвращает в rax: число, rdx : его длину в символах
; rdx = 0 если число прочитать не удалось
; Исходные данные:
;	rdi - указатель на строку
; Вывод по итогу выполнения функции:
; 	(успешное чтение числа)
;		rax - число
;		rdx - количество символов в числе
; 	(неуспешное чтение числа)
;		rdx - 0
parse_uint:
    	xor rax, rax			; очищаем rax
    	mov r10, 10				; кладем множитель 10 в r10
    	xor r9, r9				; очищаем r9 счетчик символов
.loop:
	xor r8, r8					; очищаем r8
	mov r8b, byte[rdi + r9]		; читаем первый символ
	cmp r8b, 0x30				; сравниваем код введенного символа с кодом символа '0'
	jb .exit					; если код меньше 0, то переход, так как символ - не цифра
	cmp r8b, 0x39				; сравниваем код введенного символа с кодом '9'
	ja .exit					; если код больше 9, то перехол, так как символ - не цифра
	sub r8b, 0x30				; перевод из ASCII в десятичную цифру
	mul r10						; умножаем число в rax на 10, результат в rax
	add rax, r8					; прибавляем цифру к результату
	inc r9						; инкрементируем счетчик символов
	jmp .loop					; переход к следующему символу
.exit:
	mov rdx, r9					; кладем длину числа в символах
    ret


; Принимает указатель на строку, пытается
; прочитать из её начала знаковое число.
; Если есть знак, пробелы между ним и числом не разрешены.
; Возвращает в rax: число, rdx : его длину в символах (включая знак, если он был) 
; rdx = 0 если число прочитать не удалось
; Исходные данные:
;	rdi - указатель на строку
; Вывод по итогу выполнения функции:
; (при успешном чтении числа)
;		rax - число
;		rdx - длина числа в символах
; (при неуспешном чтении числа)
;		rdx - 0
parse_int:
    	cmp byte[rdi], '-'		; проверяем, первый символ - минус?
    	jne parse_uint			; если так, то переход
    	inc rdi					; сдвигаем указатель на следующий символ
    	call parse_uint			; считываем число
    	inc rdx					; инкрементируем счетчик символок (был минус)
    	neg rax					; приводим число к нужному виду
    	ret

; Принимает указатель на строку, указатель на буфер и длину буфера
; Копирует строку в буфер
; Возвращает длину строки если она умещается в буфер, иначе 0
; Исходные данные:
;	rdi - указатель на строку
;	rsi - указатель на буфер
;	rdx - длина буфера
; Вывод по итогу выполнения функции:
;	rax - длина строки (если rax равен нулю, то строка не поместилась в буфер)
string_copy:
	push rdi					; сохраняю Caller-saved регистры		
	push rsi					; сохраняю Caller-saved регистры
	push rdx					; сохраняю Caller-saved регистры (регистры, которые нужно сохранять и восстанавливать вручную тому, кто вызывает
	call string_length			; находим длину строки вызовом нашей функцией
	inc rax						; инкрементируем rax, т.к. после строки добавляется еще нуль-терминатор
	pop rdx						; восстанавливаю Caller-saved регистры
	pop rsi						; восстанавливаю Caller-saved регистры
	pop rdi						; восстанавливаю Caller-saved регистры (регистры, которые нужно сохранять и восстанавливать вручную тому, кто вызывает)
	cmp rax, rdx				; сравниваем длину строки с длиной буфера
	jg .fail					; если длина строки больше длины буфера, то переход
.loop:
	xor r8, r8					; очищаем r8
	mov r8b, byte[rdi]			; символ идет в младший байт r8
	mov byte[rsi], r8b			; символ в буфер
	inc rdi						; сдвигаем указатель на следующий символ
	inc rsi						; сдвигаем указатель на следующую ячейку
	cmp r8b, 0					; проверяем символ на нуль-терминатора
	jne .loop					; если не нуль-терминатор, тогда дальше луп, иначе возврат
	ret
.fail:
	xor rax, rax				; очищаем rax
	ret


; Принимает указатель на строку ошибки, печатает ее
print_err:
	mov r9, 2
	jmp print_string

